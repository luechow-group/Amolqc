! Copyright (C) 2013 Alexander Sturm
!
! SPDX-License-Identifier: GPL-3.0-or-later

module mrg_m
  use kinds_m, only: r8, i8

  implicit none
  private
  public :: init_mrgran, mrg_ran, mrg_gran, mrg_intran, mrg_is_initialized

  integer,parameter :: m = 2147483647 ! 2**31 - 1
  integer(i8),parameter :: q = 4294967295_i8 ! 2**32 - 1

  ! coefficients, taken from
  ! K. Hongo, R. Maezono, K. Miura, J. Comput. Chem., 31[11], 2186-2194 (2010)
  integer :: a(8) = (/1089656042, 1906537547, 1764115693, 1304127872, &
                      189748160, 1984088114, 626062218, 1927846343/)
  ! state vector
  integer(i8) :: v(8)
  ! index to last generated random number
  integer :: y

  ! additional number generated by mrg_gran
  logical :: iset
  real(r8) :: gset

  logical :: is_initialized = .False.

contains

  real(r8) function init_mrgran(seed)
    integer, intent(in) :: seed
    integer, parameter :: b = 1812433253
    integer, parameter :: s = 30

    integer :: i

    v(1) = seed
    ! initialization by Matsumoto, 2007, ACM Trans. Model. Comput. Simul. 17 (4)
    do i = 2, 8
      v(i) = iand(b * (ieor(v(i-1), shiftr(v(i-1), s))) + i - 1, q)
    enddo
    y = 1

    init_mrgran = mrg_ran()

    is_initialized = .True.
  end function init_mrgran

  integer function mrg_intran()
    integer(i8) :: c
    integer :: i
    c = 0
    do i = 1, y - 1
      c = c + a(i) * v(y-i) ! a from 1 to y - 1, v from y - 1 to 1
    enddo
    do i = y, 8
      c = c + a(i) * v(8-i+y) ! a from y to 8, v from 8 to y
    enddo
    c = mod(c, m)

    v(y) = c
    y = iand(y, 7) + 1
    mrg_intran = c
  end function mrg_intran

  real(r8) function mrg_ran()
    integer(i8) :: a, b, s
    integer(i8), parameter :: m = 9007199254740992_i8 ! 2 ** 53
    integer, parameter :: k = 1073741823 ! 2 ** 30 - 1
    real(r8) :: r
    r = 0
    do while (r == 0)
      ! get lowest 30 bits of 2 random ints
      a = iand(mrg_intran(), k)
      b = iand(mrg_intran(), k)
      ! combine to get 53 random bits
      s = iand(ior(shiftl(a, 30), b), m - 1)
      ! convert to real with exponent 0
      r = dble(s) / m
    enddo
    mrg_ran = r
  end function mrg_ran

  real(r8) function mrg_gran()
    ! slightly modified box-muller transformation / marsaglia polar method
    real(r8) fac, rsq, v1, v2
    if(iset) then
      iset = .false.
      mrg_gran = gset
    else
      rsq = 0
      do while(rsq == 0 .or. rsq >= 1)
        v1 = 2d0 * mrg_ran() - 1d0
        v2 = 2d0 * mrg_ran() - 1d0
        rsq = v1 ** 2 + v2 ** 2
      enddo
      fac = sqrt(-2d0*log(rsq)/rsq)
      iset = .true.
      gset = v1 * fac
      mrg_gran = v2 * fac
    endif
  end function mrg_gran

  function mrg_is_initialized() result(bool)
    logical :: bool
    bool = is_initialized
  end function mrg_is_initialized
end module mrg_m
